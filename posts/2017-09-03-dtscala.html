<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Yao Li - Dependent Types in Scala</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Yao Li</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Dependent Types in Scala</h1>

            <div class="info">
    Posted on September  3, 2017
    
</div>

<blockquote>
<p>Static type systems are the world’s most successful application of formal methods. Types are simple enough to make sense to programmers; they are tractable enough to be machine-checked on every compilation; they carry no run-time overhead; and they pluck a harvest of low-hanging fruit.</p>
<p>– Brent A. Yorgey, et al. <em>Giving Haskell a Promotion</em>.</p>
</blockquote>
<h1 id="introduction">Introduction</h1>
<p>Dependent types can help prevent bugs and guide programmers to construct correct implementations, by enabling using extremely expressive types as specifications.</p>
<p>For example, in a language with full dependent type support like Gallina, you can write something like this:</p>
<pre class="Coq"><code>Fixpoint rep (A: Type) (n: nat) (a: A): Vector A n:=
    match n with
    | O =&gt; VNil A
    | S n’ =&gt; VCons A n’ a (rep A n’ a)
    end.
</code></pre>
<p>where <code>Vector A n</code> is a vector of <code>A</code> and its length is <code>n</code>. In this program, the return type of the <code>rep</code> function depends on a value, so it is called a dependent type. This program would not type check if the function implementation returns a list whose length is not <code>n</code>, hence bogus implementations are rejected.</p>
<p>Unfortunately, the above example is not directly available in most mainstream programming languages including Scala. The reason is that these languages usually enforce a phase separation between runtime values and compile-time values.</p>
<p>Nevertheless, I will show you that by using a trick called singleton types and features from Scala such as subtyping and path dependent types, we can encode the above example in Scala, and even more.</p>
<p>More specifically, in this article, we will build a vector in Scala whose length information is encoded in its type. With the information of its length at type-level, we can define the following operations:</p>
<ul>
<li>a <code>rep</code> function which takes a number, and returns a <code>Vector</code> of exactly that length.</li>
<li>an <code>app</code> function that takes two vectors, and returns a list whose length is the sum of their lengths.</li>
<li>an indexing method with compile-time bounds checking.</li>
</ul>
<h1 id="putting-numbers-in-your-types">Putting Numbers in Your Types</h1>
<p>A vector’s length ranges from 0 to infinite, so natural numbers are clearly the best representation for it. How do we encode natural numbers in Scala?</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">type</span> Nat = Int</code></pre></div>
<p>This is not ideal because we would allow negative numbers to inhabit the type of natural numbers. In this article, we particularly care about the precision of types, so we will not do that.</p>
<p>There are many ways to define natural numbers, here we are particularly interested in the following simple inductive definition:</p>
<ol>
<li>0 is a natural number.</li>
<li>if <span class="math inline"><em>n</em></span> is a natural number, then <span class="math inline"><em>S</em>(<em>n</em>)</span> is also a natural number, where <span class="math inline"><em>S</em>(<em>n</em>)</span> means the successor of <span class="math inline"><em>n</em></span> (later, we can prove that <span class="math inline"><em>S</em>(<em>n</em>)=<em>n</em> + 1</span>).</li>
</ol>
<p>We are interested in the above inductive definition because we can easily encode an inductive definition in Scala using subtyping:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">trait</span> Nat

<span class="kw">case</span> <span class="kw">object</span> Z <span class="kw">extends</span> Nat

<span class="kw">case</span> <span class="kw">class</span> <span class="fu">S</span>(n: Nat) <span class="kw">extends</span> Nat</code></pre></div>
<p>We use <code>Z</code> to denote zero, and <code>S</code> to denote successor.</p>
<p>Can we use the natural numbers we have just defined in the type of vector? The answer is clearly no. We cannot just use these runtime values as type parameters that are used at compile time in Scala. We have to find a method to represent numbers at type level. Here we use a technique called singleton types.</p>
<h2 id="singleton-types">Singleton Types</h2>
<p>Singleton types are types of those each has exactly one inhabitant. If we can define one type for each natural number, and</p>
<ol>
<li>be able to get the type from its value</li>
<li>and recover the value from its type,</li>
</ol>
<p>it seems to be equivalent to having numbers at both type- and value-level.</p>
<p>In our above encoding of natural numbers, <code>Z</code> is a value who has a singleton type <code>Z.type</code>, because that’s what <code>case object</code> means in Scala. However, <code>S(Z)</code> (i.e. 1) and <code>S(S(Z))</code> (i.e. 2) do not have singleton types associated with them, they share a common type <code>S</code> instead.</p>
<p>Here is a silly way to define singleton types for natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">trait</span> Nat

<span class="kw">case</span> <span class="kw">object</span> zero <span class="kw">extends</span> Nat

<span class="kw">case</span> <span class="kw">object</span> one <span class="kw">extends</span> Nat

<span class="kw">case</span> <span class="kw">object</span> two <span class="kw">extends</span> Nat</code></pre></div>
<p>With this encoding, we do get singleton types for natural numbers 0, 1, and 2, but there are infinitely many natural numbers, and it’s probably unwise to invest a mortal’s life in defining the infinite amount of natural numbers in this way.</p>
<p>It turns out that we can change only a little bit of our inductive definitions of natural numbers above to get singleton types:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Nat

<span class="kw">case</span> <span class="kw">object</span> Z <span class="kw">extends</span> Nat

<span class="kw">case</span> <span class="kw">class</span> S[N &lt;: Nat](n: N) <span class="kw">extends</span> Nat</code></pre></div>
<p>How is this a definition of singleton types for natural numbers? We can show that again by induction:</p>
<ol>
<li><code>Z.type</code> is a singleton type with only one inhabitant: <code>Z</code>.</li>
<li>If <code>N</code> is a singleton type, <code>S[N]</code> must also be a singleton type because there is exactly one way to construct an inhabitant of it, that is, from the sole inhabitant of <code>N</code>.</li>
</ol>
<p>We also add the <code>sealed</code> keyword in front of the <code>Nat</code> trait so it can only be inherited by classes defined in the same file. This prevents others from inhabiting more values in our types.</p>
<p>We can now open a Scala REPL and play with our natural numbers:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; Z
res1: Z.<span class="fu">type</span> = Z

scala&gt; <span class="fu">S</span>(Z)
res2: S[Z.<span class="fu">type</span>] = <span class="fu">S</span>(Z)

scala&gt; <span class="fu">S</span>(<span class="fu">S</span>(Z))
res3: S[S[Z.<span class="fu">type</span>]] = <span class="fu">S</span>(<span class="fu">S</span>(Z))</code></pre></div>
<p>It seems that we have indeed associated a singleton type with each value. However, I did mention that we should also be able to recover a value from a singleton type, right? Unfortunatly, we cannot do that yet with the code we have.</p>
<p>Let’s think for a minute how can we recover a value from a singleton type:</p>
<ul>
<li>If the type is <code>Z.type</code>, we just return <code>Z</code>. This seems easy.</li>
<li>If the type is <code>S[N]</code>, we recover the value <code>n</code> of type <code>N</code>, and then return <code>S(n)</code>. How do we recover the value of type <code>N</code>? The same process.</li>
</ul>
<p>The algorithm seems easy but here are two big problems: we need (1) pattern matching and (2) recursive calls <em>at the type level</em>!</p>
<p>This sounds like a very difficult task, if not impossible, in most programming languages, but Scala has one feature that allows us to do exactly that: <em>implicits</em>.</p>
<p>I will not go into details to explain what Scala implicits is because it is a complex concept that I myself do not understand all of it<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Instead, I will just show you the code we need and explain what happens there:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> Nat {
  <span class="kw">def</span> get[N &lt;: Nat](<span class="kw">implicit</span> v: N): N = v

  <span class="kw">implicit</span> <span class="kw">val</span> get_z: Z.<span class="fu">type</span> = Z
  <span class="kw">implicit</span> <span class="kw">def</span> get_s[N &lt;: Nat](<span class="kw">implicit</span> n: N): S[N] = <span class="fu">S</span>(n)
}</code></pre></div>
<p>We can use the above code in a Scala REPL:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; Nat.<span class="fu">get</span>[S[S[S[Z.<span class="fu">type</span>]]]]
res1: S[S[S[Z.<span class="fu">type</span>]]] = <span class="fu">S</span>(<span class="fu">S</span>(<span class="fu">S</span>(Z)))</code></pre></div>
<p>Wait, the <code>get</code> method is defined with one parameter, how did we manage to call it and get a result without even passing in an argument?</p>
<p>Here’s how it works: A parameter of a method in Scala can be declared to be implicit. If so, the programmers will not need to provide a value for this parameter, as long as the compiler can find an implicit value for it according to its type. This may at first sound like just a sugar syntax, but let’s see what this does for us:</p>
<p>Our definition of <code>get</code> method is very simple here: it simply asks the compiler to find a value of type <code>N</code> for us and returns it. But how would the Scala compiler find a value of type <code>N</code>? Let’s consider two possible cases:</p>
<ul>
<li>If the type is <code>Z.type</code>, the compiler finds that there is a implicit value <code>get_z</code> of type <code>Z.type</code> in scope, so it will just fill in <code>get_z</code> as the implicit parameter of <code>get</code>.</li>
<li>If the type is <code>S[N]</code> for some type <code>N</code>, the compiler finds that there is an implicit function that returns a value of type <code>S[N]</code>. However, this function requires another implicit parameter <code>n</code> of type <code>N</code>. How does the compiler find this implicit value of type <code>N</code>? Again, by checking the type of <code>N</code> and then trying to find an implicit definition from either <code>get_z</code> or <code>get_s</code>. The Scala compiler will try to find the implicit value recursively!</li>
</ul>
<p>As you can see, Scala implicits make the Scala compiler do pattern matchings and recursive calls automatically for us at the type level!</p>
<h2 id="vectors">Vectors</h2>
<p>Now we have numbers at the type level, we can define our vectors. How can we define such a vector? Let’s again consider the following inductive definition (for simplicity, let’s just consider of the vector of integers):</p>
<ol>
<li>Nil is a vector (more precisely, an empty vector).</li>
<li>If <span class="math inline"><em>v</em></span> is a vector and <span class="math inline"><em>x</em></span> is an arbitrary integer, <span class="math inline">cons(<em>x</em>, <em>v</em>)</span> is also a vector.</li>
</ol>
<p>We can encode the above definition easily using subtyping, but let’s also add the length information in addition to that:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat]

<span class="kw">case</span> <span class="kw">object</span> Nil <span class="kw">extends</span> Vec[Z.<span class="fu">type</span>]

<span class="kw">case</span> <span class="kw">class</span> Cons[N &lt;: Nat](h: Int, t: Vec[N]) <span class="kw">extends</span> Vec[S[N]]</code></pre></div>
<p>These definitions above should be fairly straightforward except for one caveat: <code>Cons[N]</code> should extend <code>Vec[S[N]]</code> instead of <code>Vec[N]</code>. This makes sense: the vector’s length must be at least 1 once we have used <code>Cons</code>. Another way to look at this is that <code>Cons[N]</code> means cons a value with a vector of length <code>N</code>.</p>
<p>We can play with our definition in the Scala REPL:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; Nil
res0: Nil.<span class="fu">type</span> = Nil

scala&gt; <span class="fu">Cons</span>(<span class="dv">1</span>, <span class="fu">Cons</span>(<span class="dv">2</span>, <span class="fu">Cons</span>(<span class="dv">3</span>, Nil)))
res1: Cons[S[S[Z.<span class="fu">type</span>]]] = <span class="fu">Cons</span>(<span class="dv">1</span>,<span class="fu">Cons</span>(<span class="dv">2</span>,<span class="fu">Cons</span>(<span class="dv">3</span>,Nil)))</code></pre></div>
<p>Notice that the type of <code>Cons(1, Cons(2, Cons(3, Nil)))</code> is <code>Cons[S[S[Z.type]]]</code>, which really is <code>Vec[S[S[S[Z.type]]]]</code>. We can also show this fact in the Scala REPL:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> l: Vec[S[S[S[Z.<span class="fu">type</span>]]]] = <span class="fu">Cons</span>(<span class="dv">1</span>, <span class="fu">Cons</span>(<span class="dv">2</span>, <span class="fu">Cons</span>(<span class="dv">3</span>, Nil)))
l: Vec[S[S[S[Z.<span class="fu">type</span>]]]] = <span class="fu">Cons</span>(<span class="dv">1</span>,<span class="fu">Cons</span>(<span class="dv">2</span>,<span class="fu">Cons</span>(<span class="dv">3</span>,Nil)))</code></pre></div>
<h1 id="replication">Replication</h1>
<p>Now it’s the time to get back to the example we have shown in the introduction: let’s define <code>rep</code> function which takes a number <code>n</code>, and an integer <code>x</code>, and returns a vector of <code>x</code> whose length is exactly <code>n</code>.</p>
<p>Our first problem is that, since the length <code>n</code> is given as a function parameter, we must propogate it to the type level. This is easy: just define the signature of our <code>rep</code> function as follows:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> Vec {
  <span class="kw">def</span> rep[N &lt;: Nat](n: N, x: Int): Vec[N] = ???
}</code></pre></div>
<p>It looks like the information of number <code>n</code> is repeated twice here. But don’t worry. When calling this function, we don’t need to provide the type parameter because the type inference algorithm of Scala will do this for us<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<p>Our next step is to implement this function. The most intuitive approach is shown below:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> Vec {
  <span class="kw">def</span> rep[N &lt;: Nat](n: N, x: Int): Vec[N] = n <span class="kw">match</span> {
    <span class="kw">case</span> Z =&gt; Nil
    <span class="kw">case</span> <span class="fu">S</span>(p) =&gt; <span class="fu">Cons</span>(x, <span class="fu">rep</span>(p, x))
  }
}</code></pre></div>
<p>Unfortunately, the above code snippet would not type check. Here are the errors that compiler would report to us:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="ex">error</span>] xxx.scala:24: type mismatch<span class="kw">;</span>
[<span class="ex">error</span>]  found   : Nil.type
[<span class="ex">error</span>]  required: Vec[N]
[<span class="ex">error</span>] Note: Z.type <span class="op">&lt;</span>: N (and Nil.type <span class="op">&lt;</span>: Vec[Z.type]),
        <span class="ex">but</span> trait Vec is invariant in type N.
[<span class="ex">error</span>] You may wish to define N as +N instead. (SLS 4.5)
[<span class="ex">error</span>]     case Z =<span class="op">&gt;</span> Nil
[<span class="ex">error</span>]               ^
[<span class="ex">error</span>] xxx.scala:25: type mismatch<span class="kw">;</span>
[<span class="ex">error</span>]  found   : Cons[Nat]
[<span class="ex">error</span>]  required: Vec[N]
[<span class="ex">error</span>]     case S(p) =<span class="op">&gt;</span> <span class="ex">Cons</span>(x, rep(p, x))
[<span class="ex">error</span>]                      ^
[<span class="ex">error</span>] two errors found</code></pre></div>
<p>To understand these errors, we need a little bit background in how type inference algorithms usually work with polymorphic types: they walk through the whole program or parts of the code<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> and generate some type constraints (which are the relations between types) along the way, and then try to solve those constraints to figure out the exact types.</p>
<p>Let’s try to imagine how type inference works by manually walking through the cases inside the pattern matching in our code, we will be able to know two things about the value’s type <code>N</code>:</p>
<ol>
<li>when <code>n</code> is <code>Z</code>, <code>Z.type</code> is a subtype of <code>N</code>.</li>
<li>when <code>n</code> is <code>S(p)</code> for some value <code>p</code>, its type <code>S[M]</code> is a subtype of <code>N</code> for some type <code>M</code>.</li>
</ol>
<p>We will only provide a value to parameter <code>n</code> that either has type <code>Z.type</code> or <code>S[M]</code> for some type <code>M</code>. That is, we will never use a super class of them such as <code>Nat</code>. However, there is no way to inform the Scala compiler of that. Therefore, the best the Scala compiler can do is to infer that when <code>n</code> is <code>Z</code>, <code>Z.type</code> is a subtype of <code>N</code>. There is no way to infer if that <code>Z.type = N</code>. And because our <code>Vec</code> is invariant in its type parameter <code>N</code> <a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>, <code>Vec[Z.type]</code> is not a subtype of <code>Vec[N]</code> and hence types do not match.</p>
<p>There is an easy fix to this problem: we just define <code>Vec</code> to be covariant in its type parameter <code>N</code>. However, this is not ideal because we are not precise about what is going on in our types. And even with this fix, the program will not type check because the bigger problem lies in the second error the Scala compiler has reported to us.</p>
<p>We know that when <code>n</code> is <code>S(p)</code> for some value <code>p</code>, there is a type <code>M</code> such that <code>S[M]</code> is the type of <code>S(p)</code> and a subtype of <code>N</code>, but Scala’s local type inference algorithm will not try to create a new type variable <code>M</code> here. It will, instead, try to be greedy to solve all the constraints locally and get an optimal solution for that type. In this case, that type is <code>Nat</code>. This is clearly not what we want.</p>
<p>Can we enforce the Scala compiler to create a new type variable inside pattern matching? I don’t know that answer, but let’s think about our problem again: what do we want here? We want to do pattern matchings and recursive calls with a full awareness of the type-level information. Does that sound familiar? Yes. That’s just like what we need for our <code>get</code> function of <code>Nat</code>.</p>
<p>We again employ Scala implicit to write our <code>rep</code> function. A naive approach could be like this:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> Vec {
  <span class="kw">def</span> rep[N &lt;: Nat](n: N, x: Int)(<span class="kw">implicit</span> v: Vec[N]) = v

  <span class="kw">implicit</span> <span class="kw">val</span> rep_z: Vec[Z.<span class="fu">type</span>] = Nil
  <span class="kw">implicit</span> <span class="kw">def</span> rep_s[N &lt;: Nat](x: Int)(<span class="kw">implicit</span> v: Vec[N]): Vec[S[N]] =
    <span class="fu">Cons</span>(x, v)
}</code></pre></div>
<p>This would type check but it would not give us what we want. Why? Take a look at our <code>rep_s</code> function again, it is function that has an explicit parameter as well as an implicit parameter. The Scala compiler will be able to fill in the implicit parameters of a function automatically, but it will not try to fill in the explicit ones.</p>
<p>What do we do here? Well, we just get rid of the explicit parameter. We can use some functional thinking to get arond this problem: the trick is instead of returning a implicit definition of type <code>Vec</code>, we return a function of type <code>Int =&gt; Vec</code>:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">object</span> Vec {
  <span class="kw">def</span> rep[N &lt;: Nat](n: N, x: Int)(<span class="kw">implicit</span> f: Int =&gt; Vec[N]) = <span class="fu">f</span>(x)

  <span class="kw">implicit</span> <span class="kw">val</span> rep_z: Int =&gt; Vec[Z.<span class="fu">type</span>] = (_: Int) =&gt; Nil
  <span class="kw">implicit</span> <span class="kw">def</span> rep_s[N &lt;: Nat](<span class="kw">implicit</span> f: Int =&gt; Vec[N]):
      Int =&gt; Vec[S[N]] = (x: Int) =&gt; <span class="fu">Cons</span>(x, <span class="fu">f</span>(x))
}</code></pre></div>
<p>And if we run it in a Scala REPL:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; Vec.<span class="fu">rep</span>(<span class="fu">S</span>(<span class="fu">S</span>(Z)), <span class="dv">0</span>)
res0: Vec[S[S[Z.<span class="fu">type</span>]]] = <span class="fu">Cons</span>(<span class="dv">0</span>,<span class="fu">Cons</span>(<span class="dv">0</span>,Nil))

scala&gt; Vec.<span class="fu">rep</span>(Z, <span class="dv">1</span>)
res1: Vec[Z.<span class="fu">type</span>] = Nil

scala&gt; Vec.<span class="fu">rep</span>(<span class="fu">S</span>(<span class="fu">S</span>(<span class="fu">S</span>(Z))), <span class="dv">42</span>)
res2: Vec[S[S[S[Z.<span class="fu">type</span>]]]] = <span class="fu">Cons</span>(<span class="dv">42</span>,<span class="fu">Cons</span>(<span class="dv">42</span>,<span class="fu">Cons</span>(<span class="dv">42</span>,Nil)))</code></pre></div>
<p>We can also play with our implementation. For example, if we change <code>rep_s</code> to:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">def</span> rep_s[N &lt;: Nat](<span class="kw">implicit</span> f: Int =&gt; Vec[N]):
    Int =&gt; Vec[S[N]] = (x: Int) =&gt; <span class="fu">f</span>(x)</code></pre></div>
<p>A type error will be reported:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">[<span class="ex">error</span>] xxx.scala:27: type mismatch<span class="kw">;</span>
[<span class="ex">error</span>]  found   : Vec[N]
[<span class="ex">error</span>]  required: Vec[S[N]]
[<span class="ex">error</span>]       Int =<span class="op">&gt;</span> Vec[S[N]] = (x: Int) =<span class="op">&gt;</span> <span class="ex">f</span>(x)
[<span class="ex">error</span>]                                       ^
[<span class="ex">error</span>] one error found</code></pre></div>
<p>Indeed, we need to return a vector of length <code>S[N]</code> but our implementation returns a vector of length <code>N</code>. The type checker finds a bug for us!</p>
<h1 id="append">Append</h1>
<p>Now let’s think about a more challenging problem: how to implement an <code>app</code> method for our <code>Vec</code>?</p>
<p>What would the type signature of our <code>app</code> method be like?</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat] {
  <span class="kw">def</span> app[M &lt;: Nat](b: Vec[M]): Vec[N + M]
}</code></pre></div>
<p>Defining this method is much more tricky because we need to talk about the sum of two natural numbers at the type level. Or in other words, encode a function in types.</p>
<p>Before we try to solve this problem, let’s first think about how the plus operation on natural numbers is defined. Here is one simple way of defining <span class="math inline"><em>n</em> + <em>m</em></span>:</p>
<ol>
<li>If <span class="math inline"><em>n</em> = 0</span>, then <span class="math inline"><em>n</em> + <em>m</em> = <em>m</em></span>.</li>
<li>If <span class="math inline"><em>n</em> = <em>S</em>(<em>n</em>′)</span> for some <span class="math inline"><em>n</em>′</span>, then <span class="math inline"><em>n</em> + <em>m</em> = <em>S</em>(<em>n</em>′+<em>m</em>)</span>.</li>
</ol>
<p>The second case has a recursive call. Because <span class="math inline"><em>n</em></span> is finite, we can eventually reduce any <span class="math inline"><em>n</em></span> to 0 and execute on the base case.</p>
<p>This definition is recursive and depends on the value of <span class="math inline"><em>n</em></span>. At the type level, this means we need pattern matchings and recursive definitions on types. You may be tempted to use Scala implicits, but that is used to construct function calls that will be executed at runtime. What we need here is a “function” that runs purely at compile-time.</p>
<p>Can we do that? Well, it happens that there is a feature in Scala that allows us to do exactly that: path-dependent types. Let me first show you the code and then try to explain this concept to you:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">import</span> scala.<span class="fu">language</span>.<span class="fu">higherKinds</span>

<span class="kw">sealed</span> <span class="kw">trait</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] &lt;: Nat
}

<span class="kw">case</span> <span class="kw">object</span> Z <span class="kw">extends</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] = M
}

<span class="kw">case</span> <span class="kw">class</span> S[N &lt;: Nat](n: N) <span class="kw">extends</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] = S[n.:+[M]]
}</code></pre></div>
<p>Scala allows us to declare a type in a trait, without giving a specific definition, and each subclass of that trait can give a different definition to it. In this way, the actual definition of this type depends on which subclass we are using, so it is called a path-dependent type.</p>
<p>In this example, we say <code>:+</code> is a type that should be defined by each subclass of <code>Nat</code>. The concrete type can be anything, as long as it satisfies the type refinement we have defined in <code>Nat</code>, that is, it should be a subtype of <code>Nat</code> <a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>. Notice that I define the plus operation using the symbol <code>:+</code> to distinguish it from a value-level plus operation.</p>
<p>The definitions of <code>:+</code> can be given by the subclasses of <code>Nat</code>, according to our definition of the plus operation. That is, in the case of <code>Z.type</code>, returns <code>M</code>, the other type parameter; in the case of <code>S[N]</code> for some type <code>N</code>, we do a recursive call using <code>n.:+[M]</code>, and then wrap the result with <code>S</code>.</p>
<p>To demonstrate how to use this <code>:+</code> type, we also define the plus operation as a run-time method:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] &lt;: Nat
  <span class="kw">def</span> +[M &lt;: Nat](m: M): :+[M]
}

<span class="kw">case</span> <span class="kw">object</span> Z <span class="kw">extends</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] = M
  <span class="kw">def</span> +[M &lt;: Nat](m: M): :+[M] = m
}

<span class="kw">case</span> <span class="kw">class</span> S[N &lt;: Nat](n: N) <span class="kw">extends</span> Nat {
  <span class="kw">type</span> :+[M &lt;: Nat] = S[n.:+[M]]
  <span class="kw">def</span> +[M &lt;: Nat](m: M): :+[M] = <span class="fu">S</span>(n + m)
}</code></pre></div>
<p>We are almost there to be able to define an <code>app</code> method for vectors. Here’s still one small problem: <code>:+</code> is a definition on an instance, not a class. This means that we cannot just call <code>N.:+[M]</code>. We will need to get an instance <code>n</code> of type <code>N</code>, and then call <code>n.:+[M]</code>. But we already know how to do that, right? Here’s what we are going to write down:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: N): Vec[n.:+[M]]
}

<span class="kw">case</span> <span class="kw">object</span> Nil <span class="kw">extends</span> Vec[Z.<span class="fu">type</span>] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: Z.<span class="fu">type</span>): Vec[n.:+[M]] = v
}

<span class="kw">case</span> <span class="kw">class</span> Cons[N &lt;: Nat](h: Int, t: Vec[N]) <span class="kw">extends</span> Vec[S[N]] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: S[N]): Vec[n.:+[M]] =
    <span class="fu">Cons</span>(h, t.<span class="fu">app</span>(v)(n.<span class="fu">n</span>))
}</code></pre></div>
<p>Notice that we cannot just write <code>Cons(h, t.app(v))</code> in <code>Cons.app</code>. The Scala compiler will not be able to find an implicit value of type <code>N</code> this time, because there is not enough information to help the compiler to choose from <code>get_z</code> or <code>get_s</code>. Fortunately, <em>we know</em> which value to pass to that parameter, so we just pass in that value explicitly.</p>
<h1 id="indexing">Indexing</h1>
<p>It would be no point of encoding the length information to a vector, if we do not have bounds checking for indexing. Let’s implement that.</p>
<p>Our first step is to define a less than relation between natural numbers. First, let’s try to define it mathematically:</p>
<ol>
<li><span class="math inline">0 &lt; <em>S</em>(<em>n</em>)</span> for all <span class="math inline"><em>n</em></span>.</li>
<li>If <span class="math inline"><em>n</em> &lt; <em>m</em></span>, then <span class="math inline"><em>S</em>(<em>n</em>)&lt;<em>S</em>(<em>m</em>)</span>.</li>
</ol>
<p>Again, we can encode a inductive definition at type level using subtyping:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Lt[N &lt;: Nat, M &lt;: Nat]

<span class="kw">case</span> <span class="kw">class</span> LtZ[M &lt;: Nat]() <span class="kw">extends</span> Lt[Z.<span class="fu">type</span>, S[M]]

<span class="kw">case</span> <span class="kw">class</span> LtS[N &lt;: Nat, M &lt;: Nat](lt: Lt[N, M])
    <span class="kw">extends</span> Lt[S[N], S[M]]</code></pre></div>
<p>How can we use these classes? Let’s look at them in this way: an instance of <code>Lt[N, M]</code> is a <em>proof</em> that <code>N</code> is less than <code>M</code>. Everytime we access an index in a vector, we ask the programmer to give a proof that the index is less than the length of this vector. When the index is greater than or equal to the length of the vector, there is no proof and hence no possible value to pass to the method. Therefore, the method can <em>only</em> be executed when users <em>can</em> provide a proof.</p>
<p>A first attemp may look like this:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: N): Vec[n.:+[M]]
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, N]): Int
}

<span class="kw">case</span> <span class="kw">object</span> Nil <span class="kw">extends</span> Vec[Z.<span class="fu">type</span>] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: Z.<span class="fu">type</span>): Vec[n.:+[M]] = v
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, Z.<span class="fu">type</span>]): Int =
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="st">&quot;This will never happen!&quot;</span>)
}

<span class="kw">case</span> <span class="kw">class</span> Cons[N &lt;: Nat](h: Int, t: Vec[N]) <span class="kw">extends</span> Vec[S[N]] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: S[N]): Vec[n.:+[M]] =
    <span class="fu">Cons</span>(h, t.<span class="fu">app</span>(v)(n.<span class="fu">n</span>))
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, S[N]]): Int =
    m <span class="kw">match</span> {
      <span class="kw">case</span> Z =&gt; h
      <span class="kw">case</span> <span class="fu">S</span>(p) =&gt; ??? <span class="co">// what to do here?</span>
    }
}</code></pre></div>
<p>We stuck in the case of <code>Cons.apply</code>. The problem is that when <code>m</code> is in the form of <code>S(p)</code>, we do not know how to find a proof that the type of <code>p</code> is less than <code>N</code>?</p>
<p>However, we don’t need to do a pattern matching on <code>m</code>. We can, instead, do that on the proof! Our definition of less than relations has already contained the fact whether <code>m</code> is zero. Furthermore, the proof that <span class="math inline"><em>S</em>(<em>a</em>)&lt;<em>S</em>(<em>b</em>)</span> contains the proof that $a &lt; b$!</p>
<p>Now we can get our indexing method working:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: N): Vec[n.:+[M]]
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, N]): Int
}

<span class="kw">case</span> <span class="kw">object</span> Nil <span class="kw">extends</span> Vec[Z.<span class="fu">type</span>] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: Z.<span class="fu">type</span>): Vec[n.:+[M]] = v
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, Z.<span class="fu">type</span>]): Int =
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="st">&quot;This will never happen!&quot;</span>)
}

<span class="kw">case</span> <span class="kw">class</span> Cons[N &lt;: Nat](h: Int, t: Vec[N]) <span class="kw">extends</span> Vec[S[N]] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: S[N]): Vec[n.:+[M]] =
    <span class="fu">Cons</span>(h, t.<span class="fu">app</span>(v)(n.<span class="fu">n</span>))
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(proof: Lt[M, S[N]]): Int =
    proof <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">LtZ</span>() =&gt; h
      <span class="kw">case</span> <span class="fu">LtS</span>(p) =&gt; t.<span class="fu">apply</span>(m.<span class="fu">n</span>)(p)
    }
}</code></pre></div>
<p>However, it is a quite tedious to provide a proof for the indexing. And it sometimes requires several proofs to construct one proof. The process of constructing a proof is also quite mechanical: it’s just pattern matching on the first parameter and some recursive calls at the type level. If only we can automate this!</p>
<p>Well, we can. And we have seen how to do that several times when walking through this article, right? Again, Scala implicits to the rescue!</p>
<p>Eventually, our code for this part looks like this:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Lt[N &lt;: Nat, M &lt;: Nat]

<span class="kw">case</span> <span class="kw">class</span> LtZ[M &lt;: Nat]() <span class="kw">extends</span> Lt[Z.<span class="fu">type</span>, S[M]]

<span class="kw">case</span> <span class="kw">class</span> LtS[N &lt;: Nat, M &lt;: Nat](lt: Lt[N, M])
    <span class="kw">extends</span> Lt[S[N], S[M]]

<span class="kw">object</span> Lt {
  <span class="kw">implicit</span> <span class="kw">def</span> get_ltz[M &lt;: Nat]: Lt[Z.<span class="fu">type</span>, S[M]] = <span class="fu">LtZ</span>()
  <span class="kw">implicit</span> <span class="kw">def</span> get_lts[N &lt;: Nat, M &lt;: Nat](<span class="kw">implicit</span> lt: Lt[N, M]):
      Lt[S[N], S[M]] = <span class="fu">LtS</span>(lt)
}

<span class="kw">sealed</span> <span class="kw">trait</span> Vec[N &lt;: Nat] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: N): Vec[n.:+[M]]
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(<span class="kw">implicit</span> proof: Lt[M, N]): Int
}

<span class="kw">case</span> <span class="kw">object</span> Nil <span class="kw">extends</span> Vec[Z.<span class="fu">type</span>] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: Z.<span class="fu">type</span>): Vec[n.:+[M]] = v
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(<span class="kw">implicit</span> proof: Lt[M, Z.<span class="fu">type</span>]): Int =
    <span class="kw">throw</span> <span class="kw">new</span> RuntimeException(<span class="st">&quot;This will never happen!&quot;</span>)
}

<span class="kw">case</span> <span class="kw">class</span> Cons[N &lt;: Nat](h: Int, t: Vec[N]) <span class="kw">extends</span> Vec[S[N]] {
  <span class="kw">def</span> app[M &lt;: Nat](v: Vec[M])(<span class="kw">implicit</span> n: S[N]): Vec[n.:+[M]] =
    <span class="fu">Cons</span>(h, t.<span class="fu">app</span>(v)(n.<span class="fu">n</span>))
  <span class="kw">def</span> apply[M &lt;: Nat](m: M)(<span class="kw">implicit</span> proof: Lt[M, S[N]]): Int =
    proof <span class="kw">match</span> {
      <span class="kw">case</span> <span class="fu">LtZ</span>() =&gt; h
      <span class="kw">case</span> <span class="fu">LtS</span>(p) =&gt; t.<span class="fu">apply</span>(m.<span class="fu">n</span>)(p)
    }
}</code></pre></div>
<p>Try this in our Scala REPL:</p>
<div class="sourceCode"><pre class="sourceCode Scala"><code class="sourceCode scala">scala&gt; <span class="kw">val</span> l = <span class="fu">Cons</span>(<span class="dv">1</span>, <span class="fu">Cons</span>(<span class="dv">2</span>, <span class="fu">Cons</span>(<span class="dv">3</span>, Nil)))
l: Cons[S[S[Z.<span class="fu">type</span>]]] = <span class="fu">Cons</span>(<span class="dv">1</span>,<span class="fu">Cons</span>(<span class="dv">2</span>,<span class="fu">Cons</span>(<span class="dv">3</span>,Nil)))

scala&gt; <span class="fu">l</span>(Z)
res1: Int = <span class="dv">1</span>

scala&gt; <span class="fu">l</span>(<span class="fu">S</span>(Z))
res2: Int = <span class="dv">2</span>

scala&gt; <span class="fu">l</span>(<span class="fu">S</span>(<span class="fu">S</span>(<span class="fu">S</span>(Z))))
&lt;console&gt;:<span class="dv">16</span>: error: could not find <span class="kw">implicit</span> value <span class="kw">for</span> parameter proof:
              Lt[S[S[S[Z.<span class="fu">type</span>]]],S[S[S[Z.<span class="fu">type</span>]]]]
       <span class="fu">l</span>(<span class="fu">S</span>(<span class="fu">S</span>(<span class="fu">S</span>(Z))))
        ^</code></pre></div>
<p>Notice that the last error is a compile-time error. The compiler complaints to us that it cannot find a proof to show that <span class="math inline">3 &lt; 3</span>. Indeed, there is no such proof!</p>
<h1 id="further-reading">Further Reading</h1>
<p>I want to conclude this article by listing a few reading materials.</p>
<h2 id="on-dependent-types">On Dependent Types</h2>
<p>I hope this article convinces you that dependent types can sometimes be useful by enabling you to write down.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If you want to know more about Scala implicits, I would recommend you to read a whole lot of blog posts on the Internet about it. And if you manage to understand the implicit scope, I would be extremely interested to hear about it!<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Some articles on how the type inference algorithm works may claim that the type information flows from left to right in an expression. That is wrong. Scala’s type inference algorithm is based on a technique called bidirectional type checking that was first described by <span class="citation"></span>, and later adapted by <span class="citation"></span>.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Scala employs a local type inference algorithm, so it will not walk through the entire program before it tries to solve the constraints. This is because whole-program based type inference algorithms for systems with subtyping are usually too slow to be practical.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Type <code>Vec</code> is invariant in type <code>N</code> means that no matter what subtyping relations hold for two types <code>S</code> and <code>T</code>, there is no subtyping relation between <code>Vec[S]</code> and <code>Vec[T]</code>. Two other related concepts are covariance and contravariance: covariance (declared by defining <code>Vec</code> as <code>sealed trait Vec[+N &lt;: Nat]</code> means that <code>S &lt;: T</code> implies <code>Vec[S] &lt;: Vec[T]</code>, while contravariance (declared by defining <code>Vec</code> as <code>sealed trait Vec[-N &lt;: Nat]</code>) means the opposite: <code>S &lt;: T</code> implies <code>Vec[T] &lt;: Vec[S]</code>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Some reader may realize that I am being a little inprecise here because I don’t want to confuse others with the concept of kinds. <code>:+</code> is not a type but really a type constructor that takes a type and returns another type. Think about <code>List</code>, it is not a type. <code>List[Int]</code> is. You need to provide concrete type (e.g. <code>Int</code>) to <code>List</code> to construct another concrete type (e.g. <code>List[Int]</code>). It is similar in our case of <code>:+</code>. However, for convenience, I will not try to distinguish them in this article.<a href="#fnref5">↩</a></p></li>
</ol>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
